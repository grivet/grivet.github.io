<!doctype html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="icon" href="data:,"/>
    <title>U256 | shell: waiting for a host.</title>
    <link rel="stylesheet" href="../style.css"/>
    <script src="../highlight.pack.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>
</head>
<body>
    <header>
        <div>
            <a href="../">Home</a>
        </div>
        <div>
<div id='navbar'>
<span><a href="../notes">notes</a></span>
<span><a href="./">posts</a></span>
</div>
        </div>
    </header>

<main>
    <div class="title">
        <h1>shell: waiting for a host.</h1>
        <time datetime="2020-08-18">2020-08-18</time>
    </div>
<p>A recurring pattern in my workflow has been to reboot a machine and wait for its
networking to be enabled. One issue here is that the latency until completion falls squarely within
&quot;too short to do something else, too long to stare at my screen&quot;. Instead, a shell function allows
chaining a connection event with my desktop notification bus (or, well, you know, <em>anything</em>).
The full check is for a <code>TCP</code> connection to be possible on a port, as usually access is through <code>SSH</code>.</p>
<pre><code># Run $@ until it succeeds, but allow SIGINT to cancel.
_cancellable_until () {(
    cancel=&quot;false&quot;
    until &quot;$@&quot; &gt; /dev/null; do :; done &amp;
    trap 'kill $!; cancel=&quot;true&quot;' INT
    wait $!
    trap - INT
    if [ $cancel = &quot;true&quot; ]; then
        return 1
    fi
)}

# ping $1 until it is up and port ${2:-22} is open.
waitfor () {
    port=${2:-22}
    _cancellable_until ping -W1 -c1 &quot;$1&quot; || return 1
    echo &quot;Ping ok.&quot;
    _cancellable_until nc -w 1 -z &quot;$1&quot; &quot;${port}&quot; || return 1
    echo &quot;Port ${port} is open.&quot;
}

# Usage:
$ waitfor srv0 2223 &amp;&amp; notify-send &quot;Host 'srv0' is ready.&quot;
</code></pre>
<h2>Implementation</h2>
<p>A simpler implementation could be the following:</p>
<pre><code>waitfor () {
    port=${2:-22}
    until ping -W1 -c1 &quot;$1&quot;; do :; done
    echo &quot;Ping ok.&quot;
    until nc -w 1 -z &quot;$1&quot; &quot;${port}&quot; do :; done
    echo &quot;Port ${port} is open.&quot;
}
</code></pre>
<p>Which is essentially the same. What I dislike about it is how <code>until</code> behaves in shell.
The problem is the same for any loops: when cancelling the call, <code>SIGINT</code> can either reach <code>until</code>
or the command executed. Reaching the latter, the command would exit with non-zero, meaning <code>until</code> would
not break and continue to attempt it.</p>
<p>This is a recurring issue when looping on command failures, waiting for them to succeed. This pattern thus
requires the <code>_cancellable_until</code> to be cleanly cancelled instead. This function will:</p>
<ol>
<li>Start the loop in a background process.</li>
<li>Trap to kill the previous background process when receiving <code>SIGINT</code>.</li>
<li>Wait on any child process to finish.</li>
<li>Return <code>1</code> if the child was killed using <code>SIGINT</code>.</li>
<li>Launch everything in a sub-shell to hide output noise.</li>
</ol>
<p>The intended behavior is achieved, but at what cost! All of this to have a clean wait to cancel failure loops.
Maybe more advanced shells could have better specs, but making the <code>waitfor</code> portable and clean is
harder than it should be.</p>
</main>

</body>
</html>
